---
id: ia-test3
slug: Test3
title: "Test 3 ‚Äî Algorithme de Pathfinding"
sidebar_label: Test 3
---

import InfoCard from "@site/src/components/InfoCard";
import FeatureGrid from "@site/src/components/FeatureGrid";
import Table from "@site/src/components/Table";

## Pr√©sentation <span className="badge-sticker badge-it">üß† IA</span>

<InfoCard type="info" title="Aper√ßu du test" icon="üß≠">
  Cr√©ation d'un algorithme de pathfinding permettant √† un robot de trouver le
  chemin optimal entre un point de d√©part et un point d'arriv√©e dans un
  environnement avec obstacles.
</InfoCard>

### Objectif

Ce test √©value votre capacit√© √† impl√©menter des algorithmes de recherche de chemin. Vous devrez cr√©er un algorithme capable de trouver le chemin le plus court ou le plus efficace dans un environnement donn√©.

### Algorithmes possibles

<FeatureGrid
  items={[
    {
      icon: "‚≠ê",
      title: "A*",
      description: "Algorithme A* (A-star) - Optimal et efficace",
    },
    {
      icon: "üå≥",
      title: "Dijkstra",
      description: "Algorithme de Dijkstra - Plus court chemin",
    },
    { icon: "üîÑ", title: "RRT", description: "Rapidly-exploring Random Tree" },
    { icon: "üìê", title: "RRT*", description: "RRT* - Version optimis√©e" },
    { icon: "üß©", title: "Autre", description: "Algorithme personnalis√©" },
  ]}
/>

### Fonctionnalit√©s attendues

<Table
  headers={["Fonctionnalit√©", "Description", "Priorit√©"]}
  data={[
    ["Recherche de chemin", "Trouver un chemin valide", "Obligatoire"],
    ["√âviter obstacles", "D√©tection et contournement", "Obligatoire"],
    ["Optimisation", "Chemin le plus court/rapide", "Recommand√©"],
    ["Visualisation", "Affichage graphique du chemin", "Recommand√©"],
    ["Temps r√©el", "Calcul rapide du chemin", "Bonus"],
  ]}
/>

### Structure de donn√©es

```python
class Node:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.g_cost = 0  # Co√ªt depuis le d√©part
        self.h_cost = 0  # Heuristique vers l'arriv√©e
        self.f_cost = 0  # Co√ªt total (g + h)
        self.parent = None
```

### Crit√®res de notation (100 points)

1. **Algorithme (40 points)** : Impl√©mentation correcte, optimisation
2. **Fonctionnement (30 points)** : Trouve un chemin valide, √©vite obstacles
3. **Code (15 points)** : Qualit√©, lisibilit√©, commentaires
4. **Documentation (10 points)** : Explications, sch√©mas, complexit√©
5. **Pr√©sentation (5 points)** : D√©monstration, visualisation

### Exemple A\*

```python
def a_star(start, goal, grid):
    open_set = [start]
    closed_set = []

    while open_set:
        current = min(open_set, key=lambda n: n.f_cost)
        if current == goal:
            return reconstruct_path(current)

        open_set.remove(current)
        closed_set.append(current)

        for neighbor in get_neighbors(current, grid):
            if neighbor in closed_set:
                continue

            tentative_g = current.g_cost + distance(current, neighbor)
            if neighbor not in open_set:
                open_set.append(neighbor)
            elif tentative_g >= neighbor.g_cost:
                continue

            neighbor.parent = current
            neighbor.g_cost = tentative_g
            neighbor.h_cost = heuristic(neighbor, goal)
            neighbor.f_cost = neighbor.g_cost + neighbor.h_cost
```

---

_Pour plus de d√©tails, consultez la documentation compl√®te._
