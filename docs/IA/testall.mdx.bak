---
id: ia-test1
slug: Test1
title: "Test 1 ‚Äî Classification d'images"
sidebar_label: Test 1
---

import InfoCard from "@site/src/components/InfoCard";
import FeatureGrid from "@site/src/components/FeatureGrid";
import Table from "@site/src/components/Table";

## Pr√©sentation <span className="badge-sticker badge-it">üß† IA</span>

<InfoCard type="info" title="Objectif du test" icon="üì∑">
  D√©velopper et tester un mod√®le de classification d'images pour la
  reconnaissance d'objets dans notre environnement robotique.
</InfoCard>

### üéØ Crit√®res de r√©ussite

- **Pr√©cision** : >95% sur le dataset de test
- **Temps d'inf√©rence** : &lt;100ms par image
- **Robustesse** : >90% sur donn√©es bruit√©es
- **G√©n√©ralisation** : >85% sur donn√©es non vues

### üõ†Ô∏è Environnement technique

<FeatureGrid
  items={[
    { icon: "üî•", title: "TensorFlow", description: "v2.13.0" },
    { icon: "üß†", title: "Keras", description: "v2.13.1" },
    { icon: "üëÅÔ∏è", title: "OpenCV", description: "v4.8.0" },
    { icon: "üìä", title: "NumPy", description: "v1.24.3" },
  ]}
/>

### üìä Proc√©dure de test

#### √âtape 1 : Pr√©paration des donn√©es

```python
import tensorflow as tf
from tensorflow import keras
import numpy as np
import cv2

# Configuration des param√®tres
IMG_SIZE = 224
BATCH_SIZE = 32

def load_dataset(data_path):
    # Chargement et pr√©processing des images
    pass
```

#### √âtape 2 : Architecture du mod√®le (MobileNetV2)

```python
def create_model(input_shape, num_classes):
    base_model = keras.applications.MobileNetV2(
        input_shape=input_shape,
        include_top=False,
        weights='imagenet'
    )
    base_model.trainable = False

    model = keras.Sequential([
        base_model,
        keras.layers.GlobalAveragePooling2D(),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(128, activation='relu'),
        keras.layers.Dense(num_classes, activation='softmax')
    ])
    return model
```

### üìà R√©sultats attendus

<Table
  headers={["M√©trique", "Objectif", "Statut"]}
  data={[
    ["Accuracy", ">95%", "‚úÖ"],
    ["Precision", ">94%", "‚úÖ"],
    ["Recall", ">93%", "‚úÖ"],
    ["F1-Score", ">94%", "‚úÖ"],
  ]}
/>

---

_Test r√©alis√© le : Octobre 2025_
_Responsable : P√¥le IA_






















---
id: ia-test2
slug: Test2
title: "Test 2 ‚Äî Introduction √† ROS 2"
sidebar_label: Test 2
---

import InfoCard from "@site/src/components/InfoCard";
import FeatureGrid from "@site/src/components/FeatureGrid";
import Table from "@site/src/components/Table";

## Pr√©sentation <span className="badge-sticker badge-it">ü§ñ ROS 2</span>

<InfoCard type="info" title="Aper√ßu du test" icon="üõ∞Ô∏è">
  Introduction √† ROS 2 : Apprentissage des concepts fondamentaux de ROS 2,
  cr√©ation de n≈ìuds, publication/abonnement de topics, et utilisation des
  services.
</InfoCard>

### Objectif

Ce test √©value votre capacit√© √† comprendre et utiliser ROS 2 pour cr√©er des syst√®mes robotiques distribu√©s. Vous devrez cr√©er des n≈ìuds ROS 2 capables de communiquer via topics et services.

### Concepts ROS 2

<FeatureGrid
  items={[
    { icon: "üì°", title: "Topics", description: "Publication/Subscription" },
    { icon: "üîß", title: "Services", description: "Requ√™te/R√©ponse" },
    { icon: "üó∫Ô∏è", title: "TF", description: "Transformations" },
    { icon: "üì¶", title: "Packages", description: "Organisation" },
    { icon: "üõ†Ô∏è", title: "Nodes", description: "Processus ROS 2" },
  ]}
/>

### N≈ìuds √† cr√©er

<Table
  headers={["N≈ìud", "Topic/Service", "Type", "Description"]}
  data={[
    ["publisher_node", "/chatter", "std_msgs/String", "Publication"],
    ["subscriber_node", "/chatter", "std_msgs/String", "R√©ception"],
    [
      "service_server",
      "/add_two_ints",
      "example_interfaces/AddTwoInts",
      "Service",
    ],
    [
      "service_client",
      "/add_two_ints",
      "example_interfaces/AddTwoInts",
      "Client",
    ],
  ]}
/>

### Crit√®res de notation (100 points)

1. **Compr√©hension (25 points)** : Ma√Ætrise des concepts ROS 2
2. **Impl√©mentation (40 points)** : N≈ìuds fonctionnels
3. **Documentation (20 points)** : README, commentaires
4. **Tests (10 points)** : Validation
5. **Pr√©sentation (5 points)** : D√©monstration

---

_Pour plus de d√©tails, consultez la documentation ROS 2 officielle._







































---
id: ia-test3
slug: Test3
title: "Test 3 ‚Äî Algorithme de Pathfinding"
sidebar_label: Test 3
---

import InfoCard from "@site/src/components/InfoCard";
import FeatureGrid from "@site/src/components/FeatureGrid";
import Table from "@site/src/components/Table";

## Pr√©sentation <span className="badge-sticker badge-it">üß† IA</span>

<InfoCard type="info" title="Aper√ßu du test" icon="üß≠">
  Cr√©ation d'un algorithme de pathfinding permettant √† un robot de trouver le
  chemin optimal entre un point de d√©part et un point d'arriv√©e dans un
  environnement avec obstacles.
</InfoCard>

### Objectif

Ce test √©value votre capacit√© √† impl√©menter des algorithmes de recherche de chemin. Vous devrez cr√©er un algorithme capable de trouver le chemin le plus court ou le plus efficace dans un environnement donn√©.

### Algorithmes possibles

<FeatureGrid
  items={[
    {
      icon: "‚≠ê",
      title: "A*",
      description: "Algorithme A* (A-star) - Optimal et efficace",
    },
    {
      icon: "üå≥",
      title: "Dijkstra",
      description: "Algorithme de Dijkstra - Plus court chemin",
    },
    { icon: "üîÑ", title: "RRT", description: "Rapidly-exploring Random Tree" },
    { icon: "üìê", title: "RRT*", description: "RRT* - Version optimis√©e" },
    { icon: "üß©", title: "Autre", description: "Algorithme personnalis√©" },
  ]}
/>

### Fonctionnalit√©s attendues

<Table
  headers={["Fonctionnalit√©", "Description", "Priorit√©"]}
  data={[
    ["Recherche de chemin", "Trouver un chemin valide", "Obligatoire"],
    ["√âviter obstacles", "D√©tection et contournement", "Obligatoire"],
    ["Optimisation", "Chemin le plus court/rapide", "Recommand√©"],
    ["Visualisation", "Affichage graphique du chemin", "Recommand√©"],
    ["Temps r√©el", "Calcul rapide du chemin", "Bonus"],
  ]}
/>

### Structure de donn√©es

```python
class Node:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.g_cost = 0  # Co√ªt depuis le d√©part
        self.h_cost = 0  # Heuristique vers l'arriv√©e
        self.f_cost = 0  # Co√ªt total (g + h)
        self.parent = None
```

### Crit√®res de notation (100 points)

1. **Algorithme (40 points)** : Impl√©mentation correcte, optimisation
2. **Fonctionnement (30 points)** : Trouve un chemin valide, √©vite obstacles
3. **Code (15 points)** : Qualit√©, lisibilit√©, commentaires
4. **Documentation (10 points)** : Explications, sch√©mas, complexit√©
5. **Pr√©sentation (5 points)** : D√©monstration, visualisation

### Exemple A\*

```python
def a_star(start, goal, grid):
    open_set = [start]
    closed_set = []

    while open_set:
        current = min(open_set, key=lambda n: n.f_cost)
        if current == goal:
            return reconstruct_path(current)

        open_set.remove(current)
        closed_set.append(current)

        for neighbor in get_neighbors(current, grid):
            if neighbor in closed_set:
                continue

            tentative_g = current.g_cost + distance(current, neighbor)
            if neighbor not in open_set:
                open_set.append(neighbor)
            elif tentative_g >= neighbor.g_cost:
                continue

            neighbor.parent = current
            neighbor.g_cost = tentative_g
            neighbor.h_cost = heuristic(neighbor, goal)
            neighbor.f_cost = neighbor.g_cost + neighbor.h_cost
```

---

_Pour plus de d√©tails, consultez la documentation compl√®te._
